# 운영체제의 정의

## 1. 운영체제의 정의

- 사용자에게 편리한 인터페이스를 제공하고 자원을 효율적으로 관리하는 소프트웨어



### 2. 운영체제의 핵심기능

1. 프로세스 관리
   - 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공
2. 메인메모리 관리
   - 프로세스에 작업 공간을 배치하고, 실제 메인메모리보다 큰 가상 공간을 제공한다.
3. 저장 장치 관리
   - 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다.
4. 입출력 장치 관리
   - 



## 2. 운영체제의 구조

#### 1. 커널

#### 2. 사용자 인터페이스

- 운영체제가 사용자와 응용 프로그램에 인접하여 커널에 명령을 전달하고, 실행 결과를 사용자와 응용 프로그램에 돌려주는 기능

#### 3. 운영체제의 특징



#### 4. 직접 접근과 간접 접근의 차이



#### 5. 시스템 호출

- 어떤 응용프로그램이나 사용자도 커널에 직접 접근 할 수 없음
- 대신, 운영체제에서 어떤 작업을 부탁할 때는 시스템 호출(system call)을 사용
- 사용자가 커널을 사용할 수 있도록 운영체제가 제공하는 프로그램 함수(function)의 집합



#### 6. 드라이버

- 운영체제가 하드웨어 장치와 상호 작용하려고 만든 컴퓨터 프로그램
- 장치 드라이버, 디바이스 드라이버, 장치 제어기, 소프트웨어 드라이버라고도 함
- 그래픽 카드나 프린터 같이 복잡한 드라이버는 파일, CD 형태로 제공



### 운영체제의 역사

#### 1. 유닉스

- 여러 명이 동시에 사용할 수 있는 운영체제로 1969년 AT&T의 연구원인 켄 톰프슨(Ken Thompson)이 개발
- System V
  - 오늘날의 유닉스
- BSD
  - 조금 더 상용화된 유닉스

#### 2. 리눅스

- 리누스 토르발스 개인용 컴퓨터에서 동작하는 유닉스 호환 커널 



#### 3. GNU

- 리처드 스톨먼이 만든 GNU 프로



#### 4. 윈도우



### 프로그램과 프로세스의 차이

#### 1. 프로세스

- 프로세스(process)는 하나의 작업 단위
- 사용자가 마우스를 더블클릭하여 프로그램(program)



### 프로그램

- 메모리에 올라가기 전

프로세스

- 메인 메모리에 올라와서 작업을 수행하는 동적인 상태
- 내부엔 스레드가 있지롱

- 프로세스 = 프로그램 + 프로세스 제어 블록

- 프로세스 제어 블록
  - 운영체제에서 주문서에 해당하는 것

#### 프로세스 상태

- 생성 상태
  - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, PCB 생성
- 준비 상태
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태

- 실행 상태
  - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
  - 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 반복
    - 시분할 시스템 때문
- 완료 상태
  - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입, PCB 반납

#### 프로세스 스케줄링

#### 병행 프로세스

- 병행 프로세스의 오류를 막기 위해 사용하는 개념
  - 동기화
  - 임계 영역
  - 상호 배제

#### 교착 상태

- DB에서도 일어남

  

#### 메모리 관리

- 폰노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간, 모든 프로그램은 메모리에 올라와야 실행 가능
- 과거 일괄 처리 시스템에서는 한 번에 작업 하나만 처리했기 때문에



- 고정 분할 메모리 관리



#### 메모리 구조

- 운영체제도 프로세스이기 때문에 메모리로 올라와야 실행 가능
- 메모리 관리 시스템
  - 운영체제 영역과 다른 작업 영역 침범 막기
  - 자리 부족 시 빈 공간 확보



#### 메모리 관리자가 하는 일

- 배치 작업
- 재배치 작업
- 가져오기 작업



#### 메모리 크기를 고려한 개발

- 사용자 메모리는 1GB부터 16GB까지 다양



#### 가상 메모리

- 사용자가 가지고 있는 실제 메모리 크기와 프로세스가 올라갈 메모리 위치를 신경 쓰지 않고 프로그래밍을 하도록 지원하는 메모리 시스템
- 실제 메모리 크기와 상관없이 프로세스에 

#### 가상 메모리 관리

- 페이징 기법

#### 가상 메모리 구성

- 가상 메모리는 '프로세스가 바라보는 메모 영역' 과 '메모리 관리자가 바라보는 메모리 영역'으로 나뉨
- 이론적으로 가상 메모리 크기는 무한대
- 메모리 사용 중 프로세스 중 핵심적인 기능만 메모리 위에 올려놓고 기능 수행을 할 수 있다.



#### 스왑 영역(swap area)

- 메모리가 모자라서 쫒겨난 프로세스를 저장 장치의 특별한 공간에 모아 두는 영역
- 하드디스크 같은 저장 장치는 장소만 빌려주고 메모리 관리자가 담당

- 절전 모드
  - 절전모드 사용 시 CPU와 메모리의 전력 공급을 끊기 떄문에 현재 메모리에 있는 데이터를 옮겨 가는 곳이 스왑 영역

#### 가상 메모리의 크기

- 가상 메모리 크기 = 실제 메모리 크기 + 스왑 영역 크기

- 스왑 영역 크기는 사용자가 조절 가능하나 너무 작게 하면 프로그램 실행이 불가능할 수 있음



#### 파일

- 파일 확장자
- 논리적인 데이터 집합
- 파일 구분은 확장자를 사용하고 확장자에 따라 파일 성격 구분
- 파일 이름
  - 마지막 마침표 다음 글자를 확장자로 인식
  - 현재 경로 이름을 포함하여 최대 260자(255자에서 바뀜)
  - \, /, : 등은 사용 불가

- 파일 헤더
  - 파일 이름, 버전, 크기 등등 저장
- 실행 파일과 데이터 파일
  - 실행 파일
    - 운영체제가 메모리로 가져와 CPU를 사용하여 작업하는 파일
    - 사용자 요청으로 프로세스가 되는 파일
  - 데이터 파일
    - 프로세스나 응용 프로그램이 사용하는 데이터를 모아 놓은 파일

#### 연결 프로그램

- 데이터 파일을 더블클릭하면 실행되는 응용 프로그램



#### 디렉터리

- 파일과 디렉터리
- 관련 있는 파일을 하나로 모아 놓은 곳
- 여러 층으로 구성 가능



#### 디렉터리 계층 구조

- 역슬래시(\\)는 윈도우에서는 루트 디렉터리를 의미
- 리눅스에서는 슬래시(/)가 담당



#### 파일 시스템



#### 파일 테이블

- 파일이 저장된 파일 이름, 위치 정보 등이 저장
- 모든 운영체제는 고유의 파일 테이블을 가짐
- 윈도우는 FAT(File Allocation Table)나 NTFS, 유닉스는 i-node 같은 파일 시스템 운영



#### FAT32와 NTFS

- 윈도우는 파일 시스템으로 FAT32 또는 NTFS를 사용
- FAT32는 32GB까지 지원하고 파일 하나의 크기가 4GB로 한정
- USB 메모리는 대부분 FAT32 사용
  - 4GB보다 큰 파일을 저장하려고 하면 빈 공간이 있어도 빈 공간 없음 이라는 메시지를 표시
- NTFS는 자동차나 오디오와 같은 기기에서 인식이 안될 수 있음



#### FAT 파일 시스템 구조

- 위치정보



#### 파일 세스템

- 조각화(단편화)
  - 하드디스크를 처음 사용할 때는 데이터가 앞부터 차곡차곡 쌓이지만, 사용하다 보면 

#### 빈 공간 리스트

- 디스크에 파일을 저장할 때  모든 테이블을 뒤져 빈 공간을 찾는 것을 비효율적
- 빈 공간을 효율적으로 관리하려고 파일 시스템



#### 데이터 관리

- 파일을 지우면 파일 내용이 사라지는 것이 아니라 파일 테이블에서 파일 정보만 삭제
- 새로운 파일을 저장하면 방금 지운 파일 공간에 덮어 쓰는 것이 아닌 앞의 빈 공간부터 덮어 씀
- 스마트폰에서 사용하는 클라우드 저장 장치는 자신의 스마트폰에 있는 전화번호부, 사진, 파일을 클라우드로 전송





운영체제



드라이버

38. 시스템 호출
39. BSD
40. 리눅스
41. GNU
42. 프로세스
43. PCB
44. 생성 상태
45. 준비 상태
46. 실행 상태
47. 종료 상태
48. 가지고 오기, 배치하기, 재배치
49. 배치
50. 재배치
51. 가상메모리
52. 스왑 영역
53. 스왑
54. 스왑
55. 확장자
56. 헤더
57. exe, com
58. 디렉토리
59. 루트
60. 파일 테이블
61. 포맷팅
62. 블록
63. 빈공간리스트
